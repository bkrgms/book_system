{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/esnext.iterator.constructor.js\");\nrequire(\"core-js/modules/esnext.iterator.every.js\");\nrequire(\"core-js/modules/esnext.iterator.map.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_2 = require(\"./subchannel-address\");\nconst net_1 = require(\"net\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n  constructor(shuffleAddressList) {\n    this.shuffleAddressList = shuffleAddressList;\n  }\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList\n      }\n    };\n  }\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    if ('shuffleAddressList' in obj && !(typeof obj.shuffleAddressList === 'boolean')) {\n      throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\nexports.shuffled = shuffled;\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */\nfunction interleaveAddressFamilies(addressList) {\n  const result = [];\n  const ipv6Addresses = [];\n  const ipv4Addresses = [];\n  const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);\n  for (const address of addressList) {\n    if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {\n      ipv6Addresses.push(address);\n    } else {\n      ipv4Addresses.push(address);\n    }\n  }\n  const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n  const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n  for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\n    if (i < firstList.length) {\n      result.push(firstList[i]);\n    }\n    if (i < secondList.length) {\n      result.push(secondList[i]);\n    }\n  }\n  return result;\n}\nconst REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper, credentials, options) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n    this.children = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n    this.currentPick = null;\n    /**\n     * Listener callback attached to each subchannel in the `subchannels` list\n     * while establishing a connection.\n     */\n    this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n      this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n    };\n    this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();\n    /**\n     * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n     * subchannels have failed to connect at least once, and it stays in that\n     * mode until a connection attempt is successful. While in sticky TF mode,\n     * the LB policy continuously attempts to connect to all of its subchannels.\n     */\n    this.stickyTransientFailureMode = false;\n    /**\n     * The most recent error reported by any subchannel as it transitioned to\n     * TRANSIENT_FAILURE.\n     */\n    this.lastError = null;\n    this.latestAddressList = null;\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n    this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n  }\n  allChildrenHaveReportedTF() {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n  resetChildrenReportedTF() {\n    this.children.every(child => child.hasReportedTransientFailure = false);\n  }\n  calculateAndReportNewState() {\n    if (this.currentPick) {\n      if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n          details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`\n        }));\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n      }\n    } else if (this.children.length === 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    } else {\n      if (this.stickyTransientFailureMode) {\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n          details: `No connection established. Last error: ${this.lastError}`\n        }));\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n      }\n    }\n  }\n  requestReresolution() {\n    this.channelControlHelper.requestReresolution();\n  }\n  maybeEnterStickyTransientFailureMode() {\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.requestReresolution();\n    this.resetChildrenReportedTF();\n    if (this.stickyTransientFailureMode) {\n      this.calculateAndReportNewState();\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n  removeCurrentPick() {\n    if (this.currentPick !== null) {\n      this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n      this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);\n      // Unref last, to avoid triggering listeners\n      this.currentPick.unref();\n      this.currentPick = null;\n    }\n  }\n  onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n    var _a;\n    if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          if (errorMessage) {\n            this.lastError = errorMessage;\n          }\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n  startNextSubchannelConnecting(startIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.maybeEnterStickyTransientFailureMode();\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  startConnecting(subchannelIndex) {\n    var _a, _b;\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.children[subchannelIndex].subchannel.getAddress());\n      process.nextTick(() => {\n        var _a;\n        (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS);\n    (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Declare that the specified subchannel should be used to make requests.\n   * This functions the same independent of whether subchannel is a member of\n   * this.children and whether it is equal to this.currentPick.\n   * Prerequisite: subchannel.getConnectivityState() === READY.\n   * @param subchannel\n   */\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n     * refcount dropping to 0 during this process. */\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.removeCurrentPick();\n    this.resetSubchannelList();\n    subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n    this.currentPick = subchannel;\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const child of this.children) {\n      /* Always remoev the connectivity state listener. If the subchannel is\n         getting picked, it will be re-added then. */\n      child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n  }\n  connectToAddressList(addressList) {\n    trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, {}, null),\n      hasReportedTransientFailure: false\n    }));\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    for (const child of this.children) {\n      if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n  updateAddressList(endpointList, lbConfig) {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      endpointList = shuffled(endpointList);\n    }\n    const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\n    trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n    if (rawAddressList.length === 0) {\n      throw new Error('No addresses in endpoint list passed to pick_first');\n    }\n    const addressList = interleaveAddressFamilies(rawAddressList);\n    this.latestAddressList = addressList;\n    this.connectToAddressList(addressList);\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n      this.connectToAddressList(this.latestAddressList);\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */\nclass LeafLoadBalancer {\n  constructor(endpoint, channelControlHelper, credentials, options) {\n    this.endpoint = endpoint;\n    this.latestState = connectivity_state_1.ConnectivityState.IDLE;\n    const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n      updateState: (connectivityState, picker) => {\n        this.latestState = connectivityState;\n        this.latestPicker = picker;\n        channelControlHelper.updateState(connectivityState, picker);\n      }\n    });\n    this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, credentials, Object.assign(Object.assign({}, options), {\n      [REPORT_HEALTH_STATUS_OPTION_NAME]: true\n    }));\n    this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);\n  }\n  startConnecting() {\n    this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);\n  }\n  /**\n   * Update the endpoint associated with this LeafLoadBalancer to a new\n   * endpoint. Does not trigger connection establishment if a connection\n   * attempt is not already in progress.\n   * @param newEndpoint\n   */\n  updateEndpoint(newEndpoint) {\n    this.endpoint = newEndpoint;\n    if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {\n      this.startConnecting();\n    }\n  }\n  getConnectivityState() {\n    return this.latestState;\n  }\n  getPicker() {\n    return this.latestPicker;\n  }\n  getEndpoint() {\n    return this.endpoint;\n  }\n  exitIdle() {\n    this.pickFirstBalancer.exitIdle();\n  }\n  destroy() {\n    this.pickFirstBalancer.destroy();\n  }\n}\nexports.LeafLoadBalancer = LeafLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup;","map":{"version":3,"names":["require","load_balancer_1","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","subchannel_address_2","net_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","PickFirstLoadBalancingConfig","constructor","shuffleAddressList","getLoadBalancerName","toJsonObject","getShuffleAddressList","createFromJson","obj","Error","exports","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","PickResultType","COMPLETE","status","onCallStarted","onCallEnded","shuffled","list","result","slice","i","length","j","Math","floor","random","temp","interleaveAddressFamilies","addressList","ipv6Addresses","ipv4Addresses","ipv6First","isTcpSubchannelAddress","isIPv6","host","address","push","firstList","secondList","max","REPORT_HEALTH_STATUS_OPTION_NAME","PickFirstLoadBalancer","channelControlHelper","credentials","options","children","currentState","ConnectivityState","IDLE","currentSubchannelIndex","currentPick","subchannelStateListener","previousState","newState","keepaliveTime","errorMessage","onSubchannelStateUpdate","pickedSubchannelHealthListener","calculateAndReportNewState","stickyTransientFailureMode","lastError","latestAddressList","connectionDelayTimeout","setTimeout","clearTimeout","reportHealthStatus","allChildrenHaveReportedTF","every","child","hasReportedTransientFailure","resetChildrenReportedTF","isHealthy","updateState","TRANSIENT_FAILURE","UnavailablePicker","details","getAddress","READY","QueuePicker","CONNECTING","requestReresolution","maybeEnterStickyTransientFailureMode","startConnecting","removeCurrentPick","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","removeHealthStateWatcher","unref","_a","realSubchannelEquals","index","entries","pickSubchannel","startNextSubchannelConnecting","startIndex","subchannelState","getConnectivityState","subchannelIndex","process","nextTick","_b","call","ref","addChannelzChild","resetSubchannelList","addConnectivityStateListener","addHealthStateWatcher","picker","connectToAddressList","map","subchannelAddressToString","newChildrenList","createSubchannel","updateAddressList","endpointList","lbConfig","rawAddressList","concat","endpoint","addresses","exitIdle","resetBackoff","destroy","getTypeName","LEAF_CONFIG","LeafLoadBalancer","latestState","childChannelControlHelper","createChildChannelControlHelper","connectivityState","latestPicker","pickFirstBalancer","Object","assign","updateEndpoint","newEndpoint","getPicker","getEndpoint","setup","registerLoadBalancerType","registerDefaultLoadBalancerType"],"sources":["../../src/load-balancer-pick-first.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}