{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n    var _a;\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    this.connector = connector;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.transport = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = new Set();\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.channelzTrace = new channelz_1.ChannelzTraceStub();\n      this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n      this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n      this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n    } else {\n      this.channelzTrace = new channelz_1.ChannelzTrace();\n      this.callTracker = new channelz_1.ChannelzCallTracker();\n      this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n      this.streamTracker = new channelz_1.ChannelzCallTracker();\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n    credentials._ref();\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = Object.assign(Object.assign({}, options), {\n        'grpc.keepalive_time_ms': adjustedKeepaliveTime\n      });\n    }\n    this.connector.connect(this.subchannelAddress, this.credentials, options).then(transport => {\n      if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n        this.transport = transport;\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(transport.getChannelzRef());\n        }\n        transport.addDisconnectListener(tooManyPings => {\n          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n          if (tooManyPings && this.keepaliveTime > 0) {\n            this.keepaliveTime *= 2;\n            logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n          }\n        });\n      } else {\n        /* If we can't transition from CONNECTING to READY here, we will\n         * not be using this transport, so release its resources. */\n        transport.shutdown();\n      }\n    }, error => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState, errorMessage) {\n    var _a, _b;\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    if (errorMessage) {\n      this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState] + ' with error \"' + errorMessage + '\"');\n    } else {\n      this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    for (const listener of this.stateListeners) {\n      listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n    }\n    return true;\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      this.credentials._unref();\n      process.nextTick(() => {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      });\n    }\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  createCall(metadata, host, method, listener) {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    process.nextTick(() => {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    });\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.add(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    this.stateListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    process.nextTick(() => {\n      this.backoffTimeout.reset();\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    });\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  isHealthy() {\n    return true;\n  }\n  addHealthStateWatcher(listener) {\n    // Do nothing with the listener\n  }\n  removeHealthStateWatcher(listener) {\n    // Do nothing with the listener\n  }\n  getRealSubchannel() {\n    return this;\n  }\n  realSubchannelEquals(other) {\n    return other.getRealSubchannel() === this;\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"names":["require","connectivity_state_1","backoff_timeout_1","logging","constants_1","uri_parser_1","subchannel_address_1","channelz_1","TRACER_NAME","KEEPALIVE_MAX_TIME_MS","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connector","connectivityState","ConnectivityState","IDLE","transport","continueConnecting","stateListeners","Set","refcount","channelzEnabled","backoffOptions","initialDelay","maxDelay","backoffTimeout","BackoffTimeout","handleBackoffTimer","unref","subchannelAddressString","subchannelAddressToString","keepaliveTime","_a","channelzTrace","ChannelzTraceStub","callTracker","ChannelzCallTrackerStub","childrenTracker","ChannelzChildrenTrackerStub","streamTracker","ChannelzTrace","ChannelzCallTracker","ChannelzChildrenTracker","channelzRef","registerChannelzSubchannel","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","_ref","state","children","getChildLists","target","text","LogVerbosity","DEBUG","id","refTrace","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","startConnectingInternal","adjustedKeepaliveTime","Math","min","Object","assign","connect","then","READY","refChild","getChannelzRef","addDisconnectListener","tooManyPings","log","ERROR","uriToString","shutdown","error","oldStates","newState","errorMessage","indexOf","previousState","unrefChild","isRunning","process","nextTick","_b","Error","listener","ref","unregisterChannelzRef","_unref","unrefIfOneRef","createCall","metadata","host","method","statsTracker","addCallStarted","onCallEnd","status","code","Status","OK","addCallSucceeded","addCallFailed","startConnecting","getConnectivityState","addConnectivityStateListener","add","removeConnectivityStateListener","delete","resetBackoff","getAddress","isHealthy","addHealthStateWatcher","removeHealthStateWatcher","getRealSubchannel","realSubchannelEquals","other","throttleKeepalive","newKeepaliveTime","exports"],"sources":["../../src/subchannel.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}