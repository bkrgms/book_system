{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/web.immediate.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelCall = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'subchannel_call';\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\nfunction mapHttpStatusCode(code) {\n  const details = `Received HTTP status code ${code}`;\n  let mappedStatusCode;\n  switch (code) {\n    // TODO(murgatroid99): handle 100 and 101\n    case 400:\n      mappedStatusCode = constants_1.Status.INTERNAL;\n      break;\n    case 401:\n      mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n      break;\n    case 403:\n      mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n      break;\n    case 404:\n      mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n      break;\n    case 429:\n    case 502:\n    case 503:\n    case 504:\n      mappedStatusCode = constants_1.Status.UNAVAILABLE;\n      break;\n    default:\n      mappedStatusCode = constants_1.Status.UNKNOWN;\n  }\n  return {\n    code: mappedStatusCode,\n    details: details,\n    metadata: new metadata_1.Metadata()\n  };\n}\nclass Http2SubchannelCall {\n  constructor(http2Stream, callEventTracker, listener, transport, callId) {\n    var _a;\n    this.http2Stream = http2Stream;\n    this.callEventTracker = callEventTracker;\n    this.listener = listener;\n    this.transport = transport;\n    this.callId = callId;\n    this.isReadFilterPending = false;\n    this.isPushPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.internalError = null;\n    this.serverEndedCall = false;\n    this.connectionDropped = false;\n    const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      this.httpStatusCode = headers[':status'];\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata;\n        try {\n          metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNKNOWN,\n            details: error.message,\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', headers => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', data => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      let messages;\n      try {\n        messages = this.decoder.write(data);\n      } catch (e) {\n        /* Some servers send HTML error pages along with HTTP status codes.\n         * When the client attempts to parse this as a length-delimited\n         * message, the parsed message size is greater than the default limit,\n         * resulting in a message decoding error. In that situation, the HTTP\n         * error code information is more useful to the user than the\n         * RESOURCE_EXHAUSTED error is, so we report that instead. Normally,\n         * we delay processing the HTTP status until after the stream ends, to\n         * prioritize reporting the gRPC status from trailers if it is present,\n         * but when there is a message parsing error we end the stream early\n         * before processing trailers. */\n        if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {\n          const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n          this.cancelWithStatus(mappedStatus.code, mappedStatus.details);\n        } else {\n          this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\n        }\n        return;\n      }\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      this.serverEndedCall = true;\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        var _a;\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n          return;\n        }\n        let code;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            if (this.httpStatusCode && this.httpStatusCode !== 200) {\n              const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n              code = mappedStatus.code;\n              details = mappedStatus.details;\n            } else {\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;\n            }\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            /* Bug reports indicate that Node synthesizes a NGHTTP2_CANCEL\n             * code from connection drops. We want to prioritize reporting\n             * an unavailable status when that happens. */\n            if (this.connectionDropped) {\n              code = constants_1.Status.UNAVAILABLE;\n              details = 'Connection dropped';\n            } else {\n              code = constants_1.Status.CANCELLED;\n              details = 'Call cancelled';\n            }\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = constants_1.Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = constants_1.Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata(),\n          rstCode: http2Stream.rstCode\n        });\n      });\n    });\n    http2Stream.on('error', err => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n  getDeadlineInfo() {\n    return [`remote_addr=${this.getPeer()}`];\n  }\n  onDisconnect() {\n    this.connectionDropped = true;\n    /* Give the call an event loop cycle to finish naturally before reporting\n     * the disconnection as an error. */\n    setImmediate(() => {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    });\n  }\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace('ended with status: code=' + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n      this.callEventTracker.onCallEnd(this.finalStatus);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n        this.outputStatus();\n      }\n    }\n  }\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n  tryPush(messageBytes) {\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    this.serverEndedCall = true;\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let status;\n    if (typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      this.trace('received status code ' + receivedStatus + ' from server');\n      metadata.remove('grpc-status');\n      let details = '';\n      if (typeof metadataMap['grpc-message'] === 'string') {\n        try {\n          details = decodeURI(metadataMap['grpc-message']);\n        } catch (e) {\n          details = metadataMap['grpc-message'];\n        }\n        metadata.remove('grpc-message');\n        this.trace('received status details string \"' + details + '\" from server');\n      }\n      status = {\n        code: receivedStatus,\n        details: details,\n        metadata: metadata\n      };\n    } else if (this.httpStatusCode) {\n      status = mapHttpStatusCode(this.httpStatusCode);\n      status.metadata = metadata;\n    } else {\n      status = {\n        code: constants_1.Status.UNKNOWN,\n        details: 'No status information received',\n        metadata: metadata\n      };\n    }\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n  destroyHttp2Stream() {\n    var _a;\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream.destroyed) {\n      return;\n    }\n    /* If the server ended the call, sending an RST_STREAM is redundant, so we\n     * just half close on the client side instead to finish closing the stream.\n     */\n    if (this.serverEndedCall) {\n      this.http2Stream.end();\n    } else {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    return this.transport.getPeerName();\n  }\n  getCallNumber() {\n    return this.callId;\n  }\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage = this.unpushedReadMessages.shift();\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n     * messages to emit */\n    this.http2Stream.resume();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb = error => {\n      /* nextTick here ensures that no stream action can be taken in the call\n       * stack of the write callback, in order to hopefully work around\n       * https://github.com/nodejs/node/issues/49147 */\n      process.nextTick(() => {\n        var _a;\n        let code = constants_1.Status.UNAVAILABLE;\n        if ((error === null || error === void 0 ? void 0 : error.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n          code = constants_1.Status.INTERNAL;\n        }\n        if (error) {\n          this.cancelWithStatus(code, `Write error: ${error.message}`);\n        }\n        (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n      });\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: `Write failed with error ${error.message}`,\n        metadata: new metadata_1.Metadata()\n      });\n    }\n  }\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;","map":{"version":3,"names":["require","http2","os","constants_1","metadata_1","stream_decoder_1","logging","constants_2","TRACER_NAME","getSystemErrorName","errno","name","num","Object","entries","constants","mapHttpStatusCode","code","details","mappedStatusCode","Status","INTERNAL","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","UNAVAILABLE","UNKNOWN","metadata","Metadata","Http2SubchannelCall","constructor","http2Stream","callEventTracker","listener","transport","callId","isReadFilterPending","isPushPending","canPush","readsClosed","statusOutput","unpushedReadMessages","finalStatus","internalError","serverEndedCall","connectionDropped","maxReceiveMessageLength","_a","getOptions","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","decoder","StreamDecoder","on","headers","flags","headersString","header","keys","trace","httpStatusCode","NGHTTP2_FLAG_END_STREAM","handleTrailers","fromHttp2Headers","error","endCall","message","onReceiveMetadata","data","length","messages","write","e","undefined","mappedStatus","cancelWithStatus","RESOURCE_EXHAUSTED","addMessageReceived","tryPush","maybeOutputStatus","process","nextTick","rstCode","OK","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","NGHTTP2_CANCEL","CANCELLED","NGHTTP2_ENHANCE_YOUR_CALM","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","err","syscall","onStreamEnd","getDeadlineInfo","getPeer","onDisconnect","setImmediate","outputStatus","onCallEnd","onReceiveStatus","resume","text","LogVerbosity","DEBUG","status","destroyHttp2Stream","push","Buffer","onReceiveMessage","messageBytes","pause","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","destroyed","end","close","getStatus","getPeerName","getCallNumber","startRead","nextMessage","shift","sendMessageWithContext","context","cb","callback","call","addMessageSent","halfClose","exports"],"sources":["../../src/subchannel-call.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}